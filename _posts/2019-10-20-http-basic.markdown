---
layout: post
title: HTTP基础篇
date: 2019-10-20
---

### HTTP起源

20世纪60年代，美国国防部高等研究计划署（ARPA）建立了 ARPA 网，它有四个分布在各地的节点，被认为是如今互联网的“始祖”。 然后在70年代，基于对 ARPA 网的实践和思考，研究人员发明出了著名的 TCP/IP 协议。由于具有良好的分层结构和稳定的性能，TCP/IP 协议迅速战胜其他竞争对手流行起来，并在 80 年代中期进入了 UNIX 系统内核，促使更多的计算机接入了互联网。

1989 年，任职于欧洲核子研究中心（CERN）的蒂姆·伯纳斯 - 李（Tim Berners-Lee）发表了一篇论文，提出了在互联网上构建超链接文档系统的构想。这篇论文中他确立了三项关键技术。
1. URI：即统一资源标识符，作为互联网上资源的唯一身份；
2. HTML：即超文本标记语言，描述超文本文档； 
3. HTTP：即超文本传输协议，用来传输超文本。

### HTTP版本

1. HTTP/0.9 - 20 世纪 90 年代初期
* 1993 年，NCSA（美国国家超级计算应用中心）开发出了 Mosaic，是第一个可以图文混排的浏览器
* 1995 年开发出了服务器软件 Apache，简化了 HTTP 服务器的搭建工作。 
* 1992 年发明了 JPEG 图像格式
* 1995 年发明了 MP3 音乐格式。
2. HTTP/1.0 - 1996年正式发布
* 增加了 HEAD、POST 等新方法； 增加了响应状态码，标记可能的错误原因；
* 引入了协议版本号概念；
* 引入了 HTTP Header（头部）的概念，让 HTTP 处理请求和响应更加灵活；
* 传输的数据不再仅限于文本。
3. HTTP/1.1 - 1999年正式发布、2014年修订
* 增加了 PUT、DELETE 等新的方法；
* 增加了缓存管理和控制；
* 明确了连接管理，允许持久连接；
* 允许响应数据分块（chunked），利于传输大文件；
* 强制要求 Host 头，让互联网主机托管成为可能。
4. HTTP/2.0 - 2015年（SPDY协议）
* 二进制协议，不再是纯文本；
* 可发起多个请求，废弃了 1.1 里的管道；
* 使用专用算法压缩头部，减少数据传输量；
* 允许服务器主动向客户端推送数据；
* 增强了安全性，“事实上”要求加密通信。
5. HTTP/3.0 - 2018年（QUIC协议）

#### 键入网址按下回车后，究竟发生了什么

1. 浏览器从地址栏的输入中获得服务器的 IP 地址和端口号； 

2. 浏览器用 TCP 的三次握手与服务器建立连接；

3. 浏览器向服务器发送拼好的报文；
 
4. 服务器收到报文后处理请求，同样拼好报文再发给浏览器；

5. 浏览器解析报文，渲染输出页面。

### HTTP报文

HTTP 协议的请求报文和响应报文的结构基本相同，由三大部分组成：

1. 起始行（start line）：描述请求或响应的基本信息； 
2. 头部字段集合（header）：使用 key-value 形式更详细地说明报文；
3. 消息正文（entity）：实际传输的数据，它不一定是纯文本，可以是图片、视频等二进制数据。

使用头字段需要注意下面几点：
1. 字段名不区分大小写，例如“Host”也可以写成“host”，但首字母大写的可读性更好； 
2. 字段名里不允许出现空格，可以使用连字符“-”，但不能使用下划线“_”。例如，“test-name”是合法的字段名，而“test name”“test_name”是不正确的字段名； 
3. 字段名后面必须紧接着“:”，不能有空格，而“:”后的字段值前可以有多个空格；
4. 字段的顺序是没有意义的，可以任意排列不影响语义； 
5. 字段原则上不能重复，除非这个字段本身的语义允许，例如 Set-Cookie。

### HTTP请求方法

HTTP 1.1协议规定方法如下八种：

1. GET：获取资源，可以理解为读取或者下载数据； 
2. HEAD：获取资源的元信息； 
3. POST：向资源提交数据，相当于写入或上传数据；
4. PUT：类似 POST； 
5. DELETE：删除资源；
6. CONNECT：建立特殊的连接隧道； 
7. OPTIONS：列出可对资源实行的方法； 
8. TRACE：追踪请求 - 响应的传输路径；

### HTTP状态码

* 1××：提示信息，表示目前是协议处理的中间状态，还需要后续的操作； 
* 2××：成功，报文已经收到并被正确处理； 
* 3××：重定向，资源位置发生变动，需要客户端重新发送请求； 
* 4××：客户端错误，请求报文有误，服务器无法处理； 
* 5××：服务器错误，服务器在处理请求时内部发生了错误。

目前 RFC 标准里总共有 41 个状态码，但状态码的定义是开放的，允许自行扩展。所以 Apache、Nginx 等 Web 服务器都定义了一些专有的状态码。如果你自己开发 Web 应用，也完全可以在不冲突的前提下定义新的代码。
